package msg

import (
	"encoding/binary"
	"errors"
)

type HeaderVersion uint8
type MessageType uint8
type MessageSubType uint8

// Header Length
const (
	Version HeaderVersion = 1
	Len                   = 8
)

// A custom header allows for varying payloads to be used and encoded/decoded properly
// The type and subtype fields can be used to know exactly what type of protobuf message is expected,
// preventing the use and complexities that come with using oneof
// However, this strategy is best used with a clever composition of protobuf messages.
// An example of this is using a reusable nested field that can be valid for multiple message types to reduce complexity
// and message types, which each need to be generated by the protoc compiler and take up code space

// Message Types
// // Data signifies data packet, no protobuf message
// // Control signifies protobuf message
// // Test signifies protobuf test messages
const (
	Invalid   MessageType = 0
	Control   MessageType = 1
	Data      MessageType = 2
	Keepalive MessageType = 3
)

// Control Subtypes
const (
	None           MessageSubType = 0
	Request        MessageSubType = 1
	Reply          MessageSubType = 2
	Authentication MessageSubType = 3
	Handshake      MessageSubType = 4
)

// Test SubTypes
// Signifies type of protobuf test message
const (
	TestRequest MessageSubType = 0
	TestReply   MessageSubType = 1
)

type Header struct {
	Version HeaderVersion
	Type    MessageType
	SubType MessageSubType
	MsgLen  uint32
	Unused  uint8
}

//var (
//	MessageTypeMap = map[MessageType]string{
//		Invalid: "invalid",
//		Data:    "data",
//		Control: "control",
//		Test:    "test",
//	}
//
//	SubTypeMapNone = map[MessageSubType]string{None: "none"}
//	SubTypeMap     = map[MessageType]*map[MessageSubType]string{
//		Invalid: &SubTypeMapNone,
//		Data:    &SubTypeMapNone,
//		Control: {
//			None:      "none",
//			Protobuf:  "protobuf",
//			Request:   "request",
//			Reply:     "reply",
//			KeepAlive: "keepalive",
//		},
//		Test: {
//			TestRequest: "test request",
//			TestReply:   "test reply",
//		},
//		Handshake: {
//			Request: "request",
//			Reply:   "reply",
//		},
//	}
//)

func (h *Header) Encode(b []byte, t MessageType, st MessageSubType, msglen uint32) ([]byte, error) {
	if h == nil {
		return nil, errors.New("header is nil")
	} else if cap(b) < Len {
		return nil, errors.New("provided byte array too small to encode header")
	}
	h.Version = Version
	h.Type = t
	h.SubType = st
	h.MsgLen = msglen
	h.Unused = 0

	return encodeBytes(b, h), nil
}

func encodeBytes(b []byte, h *Header) []byte {
	b = b[:Len]
	b[0] = byte(h.Version)
	b[1] = byte(h.Type)
	b[2] = byte(h.SubType)
	binary.BigEndian.PutUint32(b[3:7], h.MsgLen)
	b[7] = h.Unused
	return b
}

func (h *Header) Parse(b []byte) error {
	if len(b) < Len {
		return errors.New("header length is too short")
	}
	h.Version = HeaderVersion(b[0])
	h.Type = MessageType(b[1])
	h.SubType = MessageSubType(b[2])
	h.MsgLen = binary.BigEndian.Uint32(b[3:7])
	h.Unused = b[7]

	if h.Version != Version {
		return errors.New("header version mismatch")
	} else if h.Unused != 0 {
		return errors.New("header unused field has non-nil value")
	}

	return nil
}

//func (h *Header) String() string {
//	if h == nil {
//		return "nil"
//	}
//
//	return fmt.Sprintf("header: {version: %d type: %s subtype: %s unused: %#x", h.Version, h.TypeName(), h.SubTypeName(), h.Unused)
//}
//
//func (h *Header) TypeName() string {
//	if tn, found := MessageTypeMap[h.Type]; found {
//		return tn
//	}
//	return "unknown type"
//}
//
//func (h *Header) SubTypeName() string {
//	if n, ok := SubTypeMap[h.Type]; ok {
//		if x, ok := (*n)[h.SubType]; ok {
//			return x
//		}
//	}
//	return "unknown subtype"
//}
